/**
 * Visualizer
 *
 * Given an input audio stream, this visualizer dynamically draws shapes in 
 * response to the audio.
 *
 * Depends on the Minim library - you must import it into the sketch before it 
 * will run.
 *
 * See spec/visualizer.txt for more details.
 *
 * Notes, todo, thoughts, modifications from the spec:
 * - We have 6 shape parameters:
 *		* Position 
 *		* Angle 
 *		* Speed 
 *		* Size 
 *		* Type 
 *		* Color 
 * - However, we really only get two parameters from the music:
 *		1. On beat (boolean)
 *		2. Amplitude for this frequency band (FFT) (float, 2048 of them)
 *		(We *could* do separate FFT on the left and right channels - not sure if 
 *		  that would be interesting though.)
 *
 * - So, if we want to morph all 6 shape parameters, we'll need a few random 
 *	 variables as well.
 * - Actually, if you think about it, position/angle/speed are kind of 
 *   impacting the same thing.
 * - Proposition:
 *		* Position: derived from angle and speed
 *		* Angle: randomly generated at start, but "bounce" off of walls to stay bounded
 *		* Speed: function of BPM. basically, update position on every beat by a fixed amount
 *		* Size: function of FFT results (continuous)
 *		* Type: fixed?
 *		* Color: maybe also a function of BPM? idk
 * 
 */

import ddf.minim.*;
import ddf.minim.analysis.*;

FFT fft;
BeatDetect beat;
Minim minim;
AudioPlayer file;

/* User-defined values: */
final int BANDS = 1024;	 // Number of frequency bands - also, the number of shapes.
						 // todo: maybe decrease number of shapes by grouping bands?
final int MINSIZE = 10;  // shape sizes
final int MAXSIZE = 100; 
final int FFT_SCALE = 64; // scale the FFT results
final int SPEED = 10; // how far to advance on each beat
final int BEAT_SENSITIVITY = 300; // beat sensitivity - corresponds to 200 BPM i think?

/* References the Star class from earlier Constellation program. */
PShape createStar(float x, float y, int points, float size, color fill){
	PShape star = createShape();
	star.beginShape();
	star.fill(fill);
	star.noStroke();
    float angleOff = TWO_PI / (2 * points); // Calculate angle offset for star shape
    for (float angle = 0; angle < TWO_PI; angle += angleOff) {
      float sx = x + cos(angle) * size / 2;
      float sy = y + sin(angle) * size / 2;
      star.vertex(sx, sy);
      
      angle += angleOff;
      float bx = x + cos(angle) * size / 4; // Adjust size for star
      float by = y + sin(angle) * size / 4; // Adjust size for star
      star.vertex(bx, by);
    }
    star.endShape(CLOSE);

	return star;
}

/**
 * VizShape
 *
 * Represents a shape in the visualizer.
 *
 * @param heading: the angle of the shape
 * @param shape: the PShape object
 */
class VizShape{
	float heading;
	PShape shape;
	float oldAmp;

	VizShape(float heading, PShape shape){
		this.heading = heading;
		this.shape = shape;
		this.oldAmp = 0;
	}

	void scale(float newAmp){
		float factor = newAmp / oldAmp;
		shape.scale(factor);
		oldAmp = newAmp;
	}

	void move(int speed){
		float newX = cos(heading) * speed;
		float newY = sin(heading) * speed;
		// Perform bounds checking 
		float currentX = this.isEllipse() ? 
			shape.getParam(0) + shape.getParam(2) : 
			shape.getVertex(0).x;
		float currentY = this.isEllipse() ? 
			shape.getParam(1) + shape.getParam(3) : 
			shape.getVertex(0).y;
		if (currentX + newX < 0 || currentX + newX > width){
			heading = PI - heading;
			newX = cos(heading) * speed;
		}
		if (currentY + newY < 0 || currentY + newY > height){
			heading = -heading;
			newY = sin(heading) * speed;
		}
		shape.translate(newX, newY);
	}

	boolean isEllipse(){
		if (shape.getChildCount() > 0) {
			// Check if the first child is an ellipse (ELLIPSE type)
			PShape child = shape.getChild(0);
			return (child.getFamily() == ELLIPSE);
		}
		return false;
	}
}


float[] spectrum = new float[BANDS]; // Array of frequency bands
//PShape[] shapes = new PShape[BANDS]; // Array of shapes
VizShape[] shapes = new VizShape[BANDS]; // Array of shapes

void setup() {
	size(600, 600);         // Set the size of the canvas
	background(0);		  // Set the background color

	// Initialize audio analysis objects
	Minim minim = new Minim(this);
	file = minim.loadFile("audio.mp3", BANDS);
	fft = new FFT(file.bufferSize(), file.sampleRate());
	beat = new BeatDetect(file.bufferSize(), file.sampleRate());
	beat.setSensitivity(BEAT_SENSITIVITY); 

	// Instantiate shapes.
	for (int i = 0; i < BANDS; i++) {
		/* Shape properties to instantiate: */

		// Position: x, y
		float x = random(width);
		float y = random(height);

		// Size: width, height
		float w = random(MINSIZE, MAXSIZE);
		float h = random(MINSIZE, MAXSIZE);

		// Type: TRIANGLE, RECT, ELLIPSE
		int type = int(random(3));
		// Now create the shape
		PShape shape;
		switch(type){
			case 0: // TRIANGLE
					// technically not the randomly generated width and height but that's ok :)
				shape = createShape(TRIANGLE, x, y, x+w, y, x+(w/2), y+h);
				break;
			case 1: // RECTANGLE
				shape = createShape(RECT, x, y, w, h);
				break;
			case 2: // STAR
				shape = createStar(x, y, 5, w, color(0,0,0));
				break;
			default: // ELLIPSE
				shape = createShape(ELLIPSE, x, y, w, h);
				break;
		}

		// Angle
		float theta = random(2*PI);
		shape.rotate(theta);

		// Color
		shape.setFill(color(random(255), random(255), random(255)));

		shapes[i] = new VizShape(theta, shape);
	}

	// Start playing the audio file
	file.loop();
}

void draw() {
	background(0); // clear the canvas
	
	// perform audio analysis
	beat.detect(file.mix);
	fft.forward(file.mix);

	// if on beat, update shape positions
	if (beat.isOnset()) {
		print("BEAT\n");

		// Iterate through each shape:
		for (int i = 0; i < BANDS; i++) {
			shapes[i].move(SPEED);
		}

		/*
		for (int i = 0; i < BANDS; i++) {
			// Update positions based on FFT results
			float band = fft.getBand(i);
			print(band+"\n");
			float factor = fft.getBand(i) * FFT_SCALE;
			float newX = cos(shapeAngles[i]) * factor;
			float newY = sin(shapeAngles[i]) * factor;
			shapes[i].translate(newX, newY);
		}
		*/
	}

	// Update sizes and draw shapes
	for (int i = 0; i < BANDS; i++) {
		// Update sizes based on FFT results
		float factor = fft.getBand(i);
		shapes[i].scale(factor);
		shape(shapes[i].shape);
	}
}
